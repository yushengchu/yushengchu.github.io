[{"title":"React-Native 不使用第三方服务实现iOS&Android增量热更新","date":"2017-09-07T06:08:31.000Z","path":"2017/09/07/React-Native 不使用第三方服务实现iOS&Android增量热更新/","text":"流程图: #####简单实现:iOS Demo地址:https://github.com/yushengchu/Incremental-hot-update 123456789101112131415161718192021222324252627// 热更细管理类// HotUpdataManage.h// hotUpdataDemo//// Created by joker on 2017/9/7.// Copyright © 2017年 Facebook. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &lt;React/RCTBundleURLProvider.h&gt;#import &lt;React/RCTRootView.h&gt;@interface HotUpdataManage : NSObject//单例方法+ (HotUpdataManage*)getInstance;//获取加载URL- (NSURL*)getBridge;//检查更新- (void)checkUpdate:(NSString*)checkUrl;//bridge对象 用于重新载入jsbundle@property (nonatomic,strong) RCTBridge *bridge;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//// HotUpdataManage.m// hotUpdataDemo//// Created by joker on 2017/9/7.// Copyright © 2017年 Facebook. All rights reserved.//#import \"HotUpdataManage.h\"#import \"MXHZIPArchive.h\"#import \"DiffPatch.h\"#define HOT_MAIN_DOC_PATH [NSString stringWithFormat:@\"%@/HOTSDK/main\",NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]]#define HOT_JS_PATH [NSString stringWithFormat:@\"%@/HOTSDK/main/%@\",NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0],@\"main.jsbundle\"]@implementation HotUpdataManage+ (HotUpdataManage*)getInstance&#123; static HotUpdataManage *manager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; manager = [[HotUpdataManage alloc] init]; &#125;); return manager;&#125;#pragma mark 获取bridge- (NSURL*)getBridge&#123; NSFileManager *fileManager =[NSFileManager defaultManager]; if (![fileManager fileExistsAtPath:HOT_JS_PATH]) &#123; NSString* zipPatch = [[NSBundle mainBundle] pathForResource:@\"bundle\" ofType:@\"zip\"]; NSLog(@\"zipPatch ---&gt; %@\",zipPatch); if([fileManager fileExistsAtPath:zipPatch])&#123; BOOL isReload = [self unzipBundleAndReload:zipPatch]; //复制jsbundle文件和assest文件到到对应目录 if (isReload) &#123; return [NSURL URLWithString:HOT_JS_PATH]; &#125; &#125; &#125; return [NSURL URLWithString:HOT_JS_PATH];&#125;#pragma mark 检查更新- (void)checkUpdate:(NSString*)urlStr&#123; NSURL *url = [NSURL URLWithString: urlStr]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL: url cachePolicy: NSURLRequestUseProtocolCachePolicy timeoutInterval: 10]; [request setHTTPMethod: @\"GET\"]; NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; if (data)&#123; NSDictionary *resultInfo = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; if ([resultInfo[@\"isUpdate\"] boolValue]) &#123; [self downLoadFile:[resultInfo objectForKey:@\"updataUrl\"]]; &#125; &#125;&#125;#pragma mark 下载- (void)downLoadFile:(NSString *)urlString&#123; NSURL *url = [NSURL URLWithString:urlString]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL: url cachePolicy: NSURLRequestUseProtocolCachePolicy timeoutInterval: 10]; [request setHTTPMethod: @\"GET\"]; NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; if (data)&#123; NSLog(@\"diff下载成功\"); NSString *pacthPath = [self getFilePath:@\"diff.patch\"]; if ([data writeToFile:pacthPath atomically:YES]) &#123; [self patchBundle:pacthPath]; &#125;else&#123; NSLog(@\"diff保存失败.\"); &#125; &#125; else &#123; NSLog(@\"diff下载失败\"); &#125;&#125;- (void)patchBundle:(NSString*)pacthPath&#123; NSString* zipPatch = [[NSBundle mainBundle] pathForResource:@\"bundle\" ofType:@\"zip\"]; NSString* tmpZipPath = [NSString stringWithFormat:@\"%@/tmp.zip\",HOT_MAIN_DOC_PATH]; // 创建最新jsbundel文件 BOOL writeBundel = [DiffPatch beginPatch:pacthPath origin:zipPatch toDestination:tmpZipPath]; if (!writeBundel) &#123; NSLog(@\"bundel写入失败\"); return; &#125; if ([self unzipBundleAndReload:tmpZipPath]) &#123; [self reloadNow]; &#125; NSLog(@\"更新成功\");&#125;#pragma mark 解压-(BOOL)unzipBundleAndReload:(NSString*)zipPath&#123; //获取zipPath NSError *error; NSString *reload_zipPath = zipPath; NSString *desPath = HOT_MAIN_DOC_PATH; BOOL pathExist = [[NSFileManager defaultManager] fileExistsAtPath:desPath]; if(!pathExist)&#123; [[NSFileManager defaultManager] createDirectoryAtPath:desPath withIntermediateDirectories:YES attributes:nil error:nil]; &#125; // NSLog(@\"start unzip zip Path:%@\",reload_zipPath); [MXHZIPArchive unzipFileAtPath:reload_zipPath toDestination:desPath overwrite:YES password:nil error:&amp;error]; if(!error)&#123; NSLog(@\"解压成功,路径:%@\",desPath); return true; &#125;else&#123; NSLog(@\"解压失败,路径:%@，错误原因:%@\",desPath,[error description]); return false; &#125;&#125;#pragma mark 重新加载-(void)reloadNow&#123; [self.bridge reload]; NSLog(@\"Bridge reload\");&#125;- (NSString*)getFilePath:(NSString*)fileName&#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory =[paths objectAtIndex:0]; NSString *filePath =[documentsDirectory stringByAppendingPathComponent:fileName]; return filePath;&#125;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//AppDelegate中使用#import \"AppDelegate.h\"#import &lt;React/RCTBundleURLProvider.h&gt;#import &lt;React/RCTRootView.h&gt;#import \"HotUpdataManage.h\"@interface AppDelegate()@property (nonatomic,strong) RCTBridge *bridge;@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; HotUpdataManage* manage = [HotUpdataManage getInstance]; NSURL* localUrl = nil; #ifdef DEBUG localUrl = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index.ios\" fallbackResource:nil]; #else localUrl = [manage getBridge]; #endif //使用bridge的方式创建rootView _bridge = [[RCTBridge alloc] initWithBundleURL:localUrl moduleProvider:nil launchOptions:nil]; manage.bridge = _bridge; RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:_bridge moduleName:@\"hotUpdataDemo\" initialProperties:nil]; rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *rootViewController = [UIViewController new]; rootViewController.view = rootView; self.window.rootViewController = rootViewController; [self.window makeKeyAndVisible]; //检查更新 这里使用的是阿里的rap mock接口 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [manage checkUpdate:@\"http://rapapi.org/mockjsdata/13203/checkUpdate\"]; &#125;); return YES;&#125;@end 后言 包括pushy在内的许多支持增量热更新的类库,实际上只是对jsbundle文件进行了diff算法. 图片是通过在服务器进行筛选获取新增或者更改的图片,然后与jsbundle的diff文件一同打包成一个压缩包给客户端进行热更新. 本Demo采用的是对整个bundle.zip文件进行diff,直接获得一个针对旧版bundle.zip文件的热更新文件. iOS打包中,会默认将jsbundle和assest文件夹打入ipa包中,并不会将bundle.zip文件打入. 这一块需要通过打包脚本来实现默认将bundle.zip打入ipa包内.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"React-Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"}]},{"title":"iOS开发 悬浮窗口播放器简单实现","date":"2017-04-29T09:26:36.000Z","path":"2017/04/29/iOS开发 悬浮窗口播放器简单实现/","text":"场景 公司新项目是一个直播类型的项目,要求实现类似熊猫or斗鱼那种退出直播详情界面衔接一个悬浮(可随意拖动)的播放器继续播放.考虑到无缝衔接的需求和重新加载延迟缓冲的问题,大体定下一个思路是用一个单例对象来实现这个功能,单例对象包含一个播放器对象和一些需要用的参数等. 效果 实现 播放器使用了网易直播提供的NELivePlayer,集成该播放器可以参考网易官网的集成文档:http://vcloud.163.com/docs/live/player.html 播放器底层使用的是bilibili开源的ijkplaer 注:只能真机调试,模拟器播放器会创建失败. 流程: 1.创建PlayerShowView对象传入直播url 2.PlayerShowView内部获取PlayObj单利对象,传入直播url,获得播放器视图,添加到自身 3.PlayObj获取到直播url,判断是否已经有创建的播放器对象 || 是否是正在播放的直播等做不同操作 4.退出播放详情页-调用delloc时发送一个通知,在根视图控制器接受消息创建悬浮播放器 PlayObj.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &lt;Foundation/Foundation.h&gt;#import &lt;NELivePlayer/NELivePlayer.h&gt;#import &lt;NELivePlayer/NELivePlayerController.h&gt;#import \"Masonry.h\"#import &lt;YYKit.h&gt;#import \"UIDevice+XJDevice.h\"#import \"MLRefreshView.h\"@protocol PlayObjDelegate &lt;NSObject&gt;- (void)PlayObjFull;- (void)PlayObjclose;- (void)PlayObjRestConnect;- (void)PlayObjBack;@end@interface PlayObj : NSObject/** 直播播放器 */@property(nonatomic, strong) id&lt;NELivePlayer&gt; liveplayer;/** 播放url */@property (nonatomic, copy) NSString* liveUrl;/** 是否悬浮窗口播放 */@property (nonatomic, assign) BOOL isSuspend;/** 是否全屏 */@property (nonatomic, assign) BOOL isFull;@property (nonatomic, weak) id&lt;PlayObjDelegate&gt;delagete;+ (PlayObj*)getInstance;- (void)shutDown;@end PlayObj.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461//// PlayObj.m// ijkplayerDemo//// Created by sands on 2017/3/5.// Copyright © 2017年 wanglei. All rights reserved.//#import \"PlayObj.h\"@interface PlayObj()/** 返回按钮 */@property (nonatomic, weak) UIButton *backButton;/** 屏幕切换按钮 */@property (nonatomic, weak) UIButton *orientationButton;/** 关闭按钮 */@property (nonatomic, weak) UIButton *closeButton;/** loadingView */@property (nonatomic, weak) MLRefreshView *indicator;/** 加载提示 */@property (nonatomic, weak) UILabel* lodingTextLabel;/** 加载失败提示视图 */@property (nonatomic, weak) UIView* faildView;/** 定时器-判断加载超时 */@property (nonatomic, weak) NSTimer* inOutTimer;@property (nonatomic, assign) NSInteger inOutNumber;@endstatic PlayObj *playObj = nil;#define MAX_LODING_TIME 30 //最大加载时间 超过这个时间显示连接失败提示@implementation PlayObj+ (PlayObj*)getInstance&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; playObj = [[PlayObj alloc]init]; &#125;); return playObj;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; self.inOutTimer = 0; &#125; return self;&#125;#pragma mark =================defaultUI==================- (void)defaultWithPlaye&#123; self.liveplayer = [[NELivePlayerController alloc] initWithContentURL:[NSURL URLWithString:self.liveUrl]]; if (self.liveplayer == nil) &#123; NSLog(@\"failed to initialize!\"); &#125; self.liveplayer.view.frame = CGRectMake(0, 64, CGRectGetWidth([UIScreen mainScreen].bounds), 210); self.liveplayer.view.backgroundColor = [UIColor blackColor]; //设置播放缓冲策略，直播采用低延时模式或流畅模式，点播采用抗抖动模式，具体可参见API文档 [self.liveplayer setBufferStrategy:NELPLowDelay]; //设置画面显示模式，默认按原始大小进行播放，具体可参见API文档 [self.liveplayer setScalingMode:NELPMovieScalingModeNone]; //设置视频文件初始化完成后是否自动播放，默认自动播放 [self.liveplayer setShouldAutoplay:YES]; //设置是否开启硬件解码，IOS 8.0以上支持硬件解码，默认为软件解码 [self.liveplayer setHardwareDecoder:YES]; //设置播放器切入后台后时暂停还是继续播放，默认暂停 [self.liveplayer setPauseInBackground:NO]; [self.liveplayer prepareToPlay]; [self defaultOtherUI]; [self initNotification];&#125;- (void)defaultOtherUI&#123; if (_backButton != nil) &#123; return; &#125; @weakify(self); [self.backButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.top.mas_equalTo(@16); make.size.mas_equalTo(CGSizeMake(30.f,30.f)); &#125;]; [self.orientationButton mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.right.bottom.mas_equalTo(@(-16)); make.size.mas_equalTo(CGSizeMake(30.f, 30.f)); &#125;]; [self.indicator mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(weak_self.liveplayer.view.mas_centerY); make.centerX.mas_equalTo(weak_self.liveplayer.view.mas_centerX); make.size.mas_equalTo(CGSizeMake(20.f,20.f)); &#125;]; [self.lodingTextLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.mas_equalTo(weak_self.liveplayer.view.mas_centerX); make.top.equalTo(weak_self.indicator.mas_bottom).with.offset(5); &#125;]; [self.closeButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(@10); make.right.mas_equalTo(@-10); make.size.mas_equalTo(CGSizeMake(15.f, 15.f)); &#125;]; [self.faildView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(weak_self.liveplayer.view); make.center.mas_equalTo(weak_self.liveplayer.view); &#125;]; &#125;#pragma mark sett/** 传入url初始化播发器 @param liveUrl 直播地址 */- (void)setLiveUrl:(NSString *)liveUrl&#123; _liveUrl = liveUrl; [self defaultWithPlaye];&#125;/** 根据isSuspend展示不同的OtherUI @param isSuspend 是否悬浮窗口 */- (void)setIsSuspend:(BOOL)isSuspend&#123; _isSuspend = isSuspend; if (isSuspend) &#123; self.backButton.hidden = true; self.orientationButton.hidden = true; self.closeButton.hidden = false; &#125;&#125;/** 详情页内非全屏不显示返回按钮 @param isFull 是否全屏 */- (void)setIsFull:(BOOL)isFull&#123; _isFull = isFull; self.backButton.hidden = !_isFull; self.orientationButton.hidden = false; self.closeButton.hidden = true;&#125;#pragma mark OtherUI (返回 放大 loding 关闭 加载失败)- (UIButton*)backButton&#123; @weakify(self); if (!_backButton) &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setImage:[UIImage imageNamed:@\"player_backButton_icon_30x30_\"] forState:UIControlStateNormal]; [button setImage:[UIImage imageNamed:@\"player_backButton_pressIcon_30x30_\"] forState:UIControlStateHighlighted]; [button addBlockForControlEvents:UIControlEventTouchUpInside block:^(id _Nonnull sender) &#123; [weak_self.delagete PlayObjBack]; &#125;]; [self.liveplayer.view addSubview:button]; _backButton = button; _backButton.hidden = !_isFull; &#125; return _backButton;&#125;- (UIButton*)orientationButton&#123; if (!_orientationButton) &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setImage:[UIImage imageNamed:@\"player_fullScreen_icon_30x30_\"] forState:UIControlStateNormal]; [button setImage:[UIImage imageNamed:@\"player_fullScreen_pressIcon_30x30_\"] forState:UIControlStateHighlighted]; [button addTarget:self action:@selector(scaleFull) forControlEvents:UIControlEventTouchUpInside]; [self.liveplayer.view addSubview:button]; _orientationButton = button; &#125; return _orientationButton;&#125;- (MLRefreshView*)indicator&#123; if (!_indicator) &#123; MLRefreshView* indicator = [MLRefreshView refreshViewWithFrame:CGRectMake(0, 0, 20, 20) logoStyle:RefreshLogoNone]; [self.liveplayer.view addSubview:indicator]; _indicator = indicator; [self loadingStatus:YES]; &#125; return _indicator;&#125;- (UILabel*)lodingTextLabel&#123; if (!_lodingTextLabel) &#123; UILabel* label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 100, 20)]; label.text = @\"走心加载中\"; label.backgroundColor = [UIColor clearColor]; label.textColor = [UIColor whiteColor]; label.textAlignment = NSTextAlignmentCenter; label.font = [UIFont systemFontOfSize:11]; _lodingTextLabel = label; [self.liveplayer.view addSubview:label]; &#125; return _lodingTextLabel;&#125;- (UIButton*)closeButton&#123; @weakify(self); if (!_closeButton) &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setTitle:@\"X\" forState:UIControlStateNormal]; [button setBackgroundColor:[UIColor redColor]]; [button addBlockForControlEvents:UIControlEventTouchUpInside block:^(id _Nonnull sender) &#123; [weak_self.delagete PlayObjclose]; &#125;]; [self.liveplayer.view addSubview:button]; _closeButton = button; _closeButton.hidden = !_isSuspend; &#125; return _closeButton;&#125;- (UIView*)faildView&#123; @weakify(self); if (!_faildView) &#123; UIView* view = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; UIImageView* image = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@\"failure\"]]; image.tag = 101; image.frame = CGRectMake(0, 0, 100, 75); [view addSubview:image]; [image mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.mas_equalTo(view); &#125;]; UITapGestureRecognizer* tap = [[UITapGestureRecognizer alloc]initWithActionBlock:^(id _Nonnull sender) &#123; NSLog(@\"faild View tap\"); [weak_self.delagete PlayObjRestConnect]; _faildView.hidden = true; &#125;]; [view addGestureRecognizer:tap]; [self.liveplayer.view addSubview:view]; _faildView = view; _faildView.hidden = true; &#125; return _faildView;&#125;#pragma mark notify method- (void)initNotification&#123; // 播放器媒体流初始化完成后触发，收到该通知表示可以开始播放 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NELivePlayerDidPreparedToPlay:) name:NELivePlayerDidPreparedToPlayNotification object:_liveplayer]; // 播放器加载状态发生变化时触发，如开始缓冲，缓冲结束 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NeLivePlayerloadStateChanged:) name:NELivePlayerLoadStateChangedNotification object:_liveplayer]; // 正常播放结束或播放过程中发生错误导致播放结束时触发的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NELivePlayerPlayBackFinished:) name:NELivePlayerPlaybackFinishedNotification object:_liveplayer]; // 第一帧视频图像显示时触发的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NELivePlayerFirstVideoDisplayed:) name:NELivePlayerFirstVideoDisplayedNotification object:_liveplayer]; // 第一帧音频播放时触发的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NELivePlayerFirstAudioDisplayed:) name:NELivePlayerFirstAudioDisplayedNotification object:_liveplayer]; // 资源释放成功后触发的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NELivePlayerReleaseSuccess:) name:NELivePlayerReleaseSueecssNotification object:_liveplayer]; // 视频码流解析失败时触发的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NELivePlayerVideoParseError:) name:NELivePlayerVideoParseErrorNotification object:_liveplayer];&#125;#pragma 通知- (void)NELivePlayerDidPreparedToPlay:(NSNotificationCenter*)not&#123; NSLog(@\"// 播放器媒体流初始化完成后触发，收到该通知表示可以开始播放\"); NSLog(@\"_liveplayer = %@\",_liveplayer);&#125;- (void)NeLivePlayerloadStateChanged:(NSNotification*)not&#123; switch (self.liveplayer.loadState) &#123; case NELPMovieLoadStatePlayable: NSLog(@\"NELPMovieLoadStatePlayable 播放器初始化完成，可以播放\"); break; case NELPMovieLoadStatePlaythroughOK:&#123; NSLog(@\"NELPMovieLoadStatePlaythroughOK 缓冲完成\"); [self loadingStatus:NO]; [self.inOutTimer invalidate]; _inOutNumber = 0; &#125; break; case NELPMovieLoadStateStalled: NSLog(@\"NELPMovieLoadStateStalled 缓冲 展示loding..\"); [self loadingStatus:YES]; break; default: break; &#125;&#125;- (void)NELivePlayerPlayBackFinished:(NSNotification*)not&#123; NSLog(@\"// 正常播放结束或播放过程中发生错误导致播放结束时触发的通知\"); [self showFaildViewWithType:2];&#125;- (void)NELivePlayerFirstVideoDisplayed:(NSNotificationCenter*)not&#123; NSLog(@\"// 第一帧视频图像显示时触发的通知\"); [self loadingStatus:NO]; [self timeEnd];&#125;- (void)NELivePlayerFirstAudioDisplayed:(NSNotificationCenter*)not&#123; NSLog(@\"// 第一帧音频播放时触发的通知\");&#125;- (void)NELivePlayerReleaseSuccess:(NSNotificationCenter*)not&#123; NSLog(@\"// 资源释放成功后触发的通知\");&#125;- (void)NELivePlayerVideoParseError:(NSNotificationCenter*)not&#123; NSLog(@\"// 视频码流解析失败时触发的通知\");&#125;#pragma mark Other Method- (void)shutDown&#123; [self.liveplayer shutdown]; [self.liveplayer.view removeFromSuperview]; self.liveplayer = nil; _liveUrl = @\"\"; [self removePlaySub]; [self timeEnd];&#125;- (void)removePlaySub&#123; _faildView = nil; _orientationButton = nil; _closeButton = nil; _indicator = nil; _lodingTextLabel = nil; _backButton = nil;&#125;/** 全屏 */- (void)scaleFull&#123; [self.delagete PlayObjFull];&#125;- (void)loadingStatus:(BOOL)status&#123; _indicator.hidden = !status; _lodingTextLabel.hidden = _indicator.hidden; if (status) &#123; [_indicator startAnimation]; _inOutTimer = 0; self.inOutTimer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(checkLiveTimerOut:) userInfo:nil repeats:YES]; &#125;else&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [_indicator stopAnimation]; &#125;); &#125;&#125;- (void)checkLiveTimerOut:(NSTimer*)timer&#123; _inOutNumber++; NSLog(@\"checkLiveTimerOut %ld\",(long)_inOutNumber); if (_inOutNumber&gt;=20) &#123; _indicator.hidden = true; _lodingTextLabel.hidden = true; [self.liveplayer stop]; [self showFaildViewWithType:1]; &#125;&#125;- (void)timeEnd&#123; [_inOutTimer invalidate]; _inOutNumber = 0; _inOutTimer = nil;&#125;/** 展示错误提示View @param type 1:点击重连 2:主播下播 */- (void)showFaildViewWithType:(NSInteger)type&#123; if (type == 1) &#123; _faildView.hidden = false; _faildView.userInteractionEnabled = true; &#125;else if(type == 2)&#123; UIImageView* imageView = [_faildView viewWithTag:101]; if (imageView) &#123; imageView.image = [UIImage imageNamed:@\"live_icon_absent\"]; &#125; _faildView.hidden = false; _faildView.userInteractionEnabled = false; [self loadingStatus:false]; &#125; [self timeEnd];&#125;@end PlayerShowView.h 12345678910111213141516171819202122232425262728//// PlayerShowView.h// NEPlyaer//// Created by fhzx_mac on 2017/3/9.// Copyright © 2017年 sandsyu. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;#import \"Masonry.h\"#import &lt;NELivePlayer/NELivePlayer.h&gt;#import &lt;NELivePlayer/NELivePlayerController.h&gt;@interface PlayerShowView : UIView- (instancetype)initWithFrame:(CGRect)frame connectWithUrl:(NSString*)url;@property (nonatomic, strong) id&lt;NELivePlayer&gt; liveplayer;@property (nonatomic, copy) NSString* url;@property (nonatomic, assign) BOOL isFull;@property (nonatomic, assign) BOOL isSuspend;@property (nonatomic, assign) CGRect oldFrame;@end PlayerShowView.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// PlayerShowView.m// NEPlyaer//// Created by fhzx_mac on 2017/3/9.// Copyright © 2017年 sandsyu. All rights reserved.//#import \"PlayerShowView.h\"#import \"PlayObj.h\"@interface PlayerShowView()&lt;PlayObjDelegate&gt;@end@implementation PlayerShowView- (instancetype)initWithFrame:(CGRect)frame connectWithUrl:(NSString*)url&#123; self = [super initWithFrame:frame]; if (self) &#123; self.url = url; [self defaultUI]; &#125; return self;&#125;- (void)defaultUI&#123; @weakify(self); if ([PlayObj getInstance].liveUrl.length&lt;=0) &#123; [PlayObj getInstance].liveUrl = self.url; &#125;else&#123; self.url = [PlayObj getInstance].liveUrl; &#125; [PlayObj getInstance].delagete = self; [self addSubview:[PlayObj getInstance].liveplayer.view]; [self sendSubviewToBack:self.liveplayer.view]; [[PlayObj getInstance].liveplayer.view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.size.mas_equalTo(weak_self); make.center.mas_equalTo(weak_self); &#125;]; [PlayObj getInstance].isSuspend = self.isSuspend;&#125;- (void)setIsSuspend:(BOOL)isSuspend&#123; _isSuspend = isSuspend; [PlayObj getInstance].isSuspend = _isSuspend;&#125;- (void)setIsFull:(BOOL)isFull&#123; _isFull = isFull; [PlayObj getInstance].isFull = isFull;&#125;-(void)PlayObjFull&#123; @weakify(self); if (!_isFull) &#123; weak_self.oldFrame = weak_self.frame; weak_self.viewController.navigationController.navigationBar.hidden = true; [UIDevice setOrientation:UIInterfaceOrientationLandscapeRight]; weak_self.frame = weak_self.window.bounds; weak_self.isFull = true; &#125;else&#123; weak_self.viewController.navigationController.navigationBar.hidden = false; [UIDevice setOrientation:UIInterfaceOrientationPortrait]; weak_self.frame = weak_self.oldFrame; weak_self.isFull = false; &#125;&#125;- (void)PlayObjclose&#123; [[PlayObj getInstance]shutDown]; [self removeFromSuperview];&#125;- (void)PlayObjRestConnect&#123; [[PlayObj getInstance]shutDown]; [self defaultUI];&#125;- (void)PlayObjBack&#123; [self PlayObjFull];&#125;@end 使用: 12345PlayerShowView* View = [[PlayerShowView alloc]initWithFrame:CGRectMake(0, 100, self.view.width, self.view.width*0.6) connectWithUrl:self.liveUrl];View.isFull = false;View.isSuspend = false;[self.view addSubview:View]; 具体实现可以参考github上的代码:https://github.com/yushengchu/NEPlyaer DEMO使用:播放器静态库文件过大上传到百度云https://pan.baidu.com/s/1i4FDtm1下载解压,放入项目根目录(xcodeproj文件所在目录)运行即可","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"}]},{"title":"git使用实录 文件过大无法提交问题解决","date":"2017-04-29T09:26:36.000Z","path":"2017/04/29/git使用实录 提交记录包含过大文件问题/","text":"前言 开发中遇到一个比较蛋疼的问题,因为新公司的项目是直播类型,集成网易的播放器SDK,静态库文件大小103MB超过了git提交文件的限制,且已经被我添加到commit记录中,等反应过来已经为时已晚.不管是回滚还是删除对应文件亦或者添加忽略,提交时都会报文件过大的错误,记录一下自己解决的方法.最后解决办法是先获取所有提交记录中大文件的列表,然后进行删除,因为涉及到对以往提交记录的修改,其实还是有一定风险的. 过程 1.获取大文件列表 1git rev-list --objects --all | grep \"$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '&#123;print$1&#125;')\" 输出: 123466b9f17406fb109070c29a611f2b9e37cce5eecb NELivePlayer/libs/libNELivePlayer.ad62d664624dc4668bf02fa307a4b7877714cdad5 Pods/PLPlayerKit/Pod/Library/lib/libPLPlayerKit.aa03e179bd2a474326afd6f594de933aa9bd9b9f0 Pods/PLPlayerKit/Pod/Library/lib/libavcodec.aa44851e9099ceaf519e595cbb416d267ee4bbb18 Pods/PLPlayerKit/Pod/Library/lib/libcrypto.a libNELivePlayer.a就是报错的罪魁祸首 删除所有带有libNELivePlayer.a文件的记录1git filter-branch -f --prune-empty --index-filter 'git rm -rf --cached --ignore-unmatch NELivePlayer/libs/libNELivePlayer.a' --tag-name-filter cat -- --all 执行完 再回到sourcetree,可以看到含有libNELivePlayer.a的提交记录都已经不见了,重新点提交,问题解决.","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"}]},{"title":"使用Jenkins+Git+蒲公英搭建iOS持续集成平台","date":"2017-02-14T05:12:10.000Z","path":"2017/02/14/使用Jenkins+Git+蒲公英搭建iOS持续集成平台/","text":"Jenkins介绍 Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：1、持续的软件版本发布/测试项目。2、监控外部调用执行的工作。 - Jenkins安装 Jenkins可以通过命令行安装,也可以通过pkg文件安装,下载地址https://jenkins.io/index.html 安装完成之后可以在Terminal中通过命令启动Jenkins. 12//启动Jenkinsopen /Applications/Jenkins/jenkins.war 启动后在浏览器地址框输入http://localhost:8080/就可以打开Jenkins界面 注:默认端口是8080,如果8080端口被占用可以通过Terminal命令来改变Jenkins的启动端口1defaults write /Library/Preferences/org.jenkins-ci httpPort 7070 - Jenkins构建配置 ####1.插件安装需要安装四个插件: 1234Xcode integrationGIT pluginPost-Build Script Plug-inGitHub plugin 安装方法: ####2.创建-配置项目2.1点击新建-输入项目名称-构建一个自由风格的软件项目 2.2设置源码 设置SSH key 2.3构建 设置General build settings信息 设置Code signing &amp; OS X keychain options ####注:keychian文件地址为${HOME}/Library/Keychains/login.keychain 2.4设置构建后操作-上传到蒲公英 12//蒲公英上传脚本代码curl -F \"ipa文件地址\" -F \"uKey=用户uKey\" -F \"_api_key=_api_key\" https://qiniu-storage.pgyer.com/apiv1/app/upload 2.5点击保存-返回项目首页点击构建 蒲公英上的项目也正常上传了. - 自定义网页展示 蒲公英提供了开放API可以查询我们上传的APP,具体信息查看蒲公英开放文档.https://www.pgyer.com/doc/api#paramInfo这里使用viewGroup接口,获取上传的APP所有版本信息 并在网页上展示,方便测试人员进行扫码安装 注:如果不是企业账号打包的ipa文件 需要提前将测试人员的测试设备添加到开发者账号中 效果展示: 自定义网页项目代码地址:https://github.com/yushengchu/JenkinsPlatform 觉得有用的小伙伴不妨点个start!","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"app","slug":"app","permalink":"http://yoursite.com/tags/app/"}]},{"title":"RAP+MockJS创建Mock测试数据","date":"2017-01-24T03:10:46.000Z","path":"2017/01/24/RAP+MockJS创建Mock测试数据/","text":"前言 在项目开发中经常会用到模拟接口或者说是假数据,一般做法是 读取本地json文件 写死一个数据对象 使用本地接口服务器 这几种做法固然能满足开发上的需求,却无法很真实的去模拟用户使用产品时的真正情况,数据灵活性上也存在不足. 介绍 RAP是阿里开发人员开发的一款假数据生成平台,可以动态配置接口返回数据,使用mock语法随机生成数据. 使用 1.注册登陆 1http://rap.taobao.org/ 2.创建团队-产品线-分组-项目 3.创建测试接口定义测试数据 点击创建的项目进入项目编辑页面,点击搜索框边的编辑按钮开始编辑接口.可以定义该接口需要的请求参数和该接口返回的参数列表 例: 1234567891011121314151617//需要返回一段这样的数据&#123; \"Success\": true, \"Data\": [ &#123; \"Author\": \"rkhg\", \"CreateTimer\": \"1976-06-05 18:50:15\", \"ImageUrl\": \"http://dummyimage.com/300x150/20bc62)\", \"Titile\": \"这是标题340000200812217470\" &#125;, &#123; \"Author\": \"fmsuett\", \"CreateTimer\": \"1986-05-17 23:00:53\", \"ImageUrl\": \"http://dummyimage.com/300x150/052a27)\", \"Titile\": \"这是标题820000200001248542\" &#125;&#125; 对应配置方法: mock数据规则: 定义完成接口后点击秒存保存数据可以点击接口详情边上的红色mock数据按钮,预览接口返回的数据","tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"},{"name":"服务端","slug":"服务端","permalink":"http://yoursite.com/tags/服务端/"}]},{"title":"swift服务端初探1:Vapor框架的安装及基本post/get请求使用","date":"2016-12-27T06:20:33.000Z","path":"2016/12/27/swift服务端初探1-Vapor框架的安装及基本post:get请求使用/","text":"前言 距离swift发布已经过去了很长一段时间,版本也攀升到了swift3.0.2,swift可以用于开发服务端程序,这让iOS开发者有了一个用同种语言开发前后端的机会,这无疑是一件让人感到非常cool的事情. Vapor安装 Vapor的安装十分简单,使用终端输出三个命令即可. 123456//检查安装环境$ curl -sL check.vapor.sh | bash//安装$ curl -sL toolbox.vapor.sh | bash//查看是否安装成功$ vapor --help 看到这样的反馈,就已经是安装成功的状态了! Vapor使用 1. 创建项目 vapor new PorjectName 2. 创建XCode项目 //进入项目目录输入命令 $ vapor xcode -y 3. 修改代码 4. 运行 cmmamd+R 1.创建项目打开终端 输入vapor new PorjectName,耐心等待出现以下界面项目就创建完毕了! 2.创建Xcode项目这一步是可以省略的,Vapor可以直接在终端进行运行,个人还是比较喜欢用Xcode来运行.在终端进入新建的Vapor项目目录输入vapor xcode -y出现以下界面即为完成. 3.修改代码找到Sources/App目录下的main.swift文件 123let drop = Droplet()//这两行代码中间的代码全部删除drop.run() get请求: 1234567891011121314//get//无参数get返回drop.get &#123; _ in return try JSON(node:[ \"message\":\"hello,world!\" ])&#125;// 0.0.0.0:8080/hello 返回drop.get(\"hello\") &#123; request in return try JSON (node: [ \"message\": \"hello,world!\" ])&#125; post请求: 1234567891011//postdrop.post(\"post\")&#123; request in //对提取的参数进行guard判断 不符合则返回一个失败的请求 guard let name = request.data[\"name\"]?.string else&#123; throw Abort.badRequest &#125; //json序列化输出 return try JSON(node: [ \"name\": \"hello \\(name)!\" ])&#125; 4.运行项目Commamd+R运行,运行完成控制台会输出本地调试的地址. get请求效果: post请求效果(使用postman): 后语 做到这一步,就可以使用Vapor来做一个本地API服务器了,也可以将Vapor部署到远程服务器上,作为远程服务器来使用,Vapor更多功能使用可以去Vapor的官网http://vapor.codes/ 查看文档.","tags":[{"name":"服务端","slug":"服务端","permalink":"http://yoursite.com/tags/服务端/"},{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"},{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"基于Xcode的iOS原生UI测试框架 UITests使用 简单case","date":"2016-12-22T09:31:47.000Z","path":"2016/12/22/基于Xcode的iOS原生UI测试框架 UITests使用 简单case/","text":"前言 随着APP功能的不断增加,仅仅靠黑盒测试人工来覆盖测试无疑有很大的局限性,效果也不如人意,尤其是新功能增加后可能要对旧功能做回归测试,产生了大量的重复工作,而这些重复工作有一些是可以通过自动化测试进行完成的,UITests的出现就是为了解决这个问题. UItests介绍 UITests是什么? UItests是由苹果公司开发的一个自动测试UI交互的自动化测试框架 UItests能做什么? UItests可以帮助我们解决一些测试上的重复工作,节省人工成本,提高测试效率等. UITests使用 新创建的项目可以通过勾选include UI Tests来添加 现有项目可以通过以下步骤来添加. 成功添加UITests组件后,在项目文件导航里可以看到对应目录. UITestDemoUITests.m就是用来编写测试案例的文件. 注:测试方法都是以test开头的 测试代码可以通过录制和直接编写两种方法来生成,建议先通过自动生成 然后修改自动生成的代码. 声明一个新的测试方法 点击小圆点 自动打开模拟器运行项目 对项目的操作会被用代码的形式记录下来自动记录的代码也十分好理解,点击了login按钮 再点击了id为Detail的导航栏上的Mune按钮点击左上角的棱形标志则代表执行这个测试方法,自动打开模拟器执行.测试方法执行成功标志內出现一个绿勾,失败则是红叉.测试进行中会在控制台打印参数,包括当前操作 耗时等,测试完成则会打印测试log保存地址. 简单测试案例 12345678910111213141516171819202122232425262728293031323334- (void)testLogi&#123; XCUIElement *account = [[XCUIApplication alloc] init].textFields[@\"account\"]; XCUIElement *pwd = [[XCUIApplication alloc] init].textFields[@\"password\"]; XCUIApplication *app = [[XCUIApplication alloc] init]; //判断账号密码是否都是偶数 是则跳转 不是则直接下一次测试 //跳转后等待3s 返回登录界面 int success = 0; int failed = 0; for (int i = 0; i&lt;10; i++) &#123; int acc = arc4random() % 1000; int pw = arc4random() % 1000; [account tap]; [account typeText:[NSString stringWithFormat:@\"%d\",acc]]; [pwd tap]; [pwd typeText:[NSString stringWithFormat:@\"%d\",pw]]; //点击登录 [app.buttons[@\"login\"] tap]; //模拟正常登录网络访问等待3s [app.windows.navigationBars.element pressForDuration:3]; //判断是否跳转到登录之后的界面 如果是 则登录成功 if ([app.navigationBars.element.identifier isEqualToString:@\"Detail\"]) &#123; [app.navigationBars[@\"Detail\"].buttons[@\"Mune\"] tap]; NSLog(@\"登录成功\"); success += 1; &#125;else&#123; NSLog(@\"登录失败\"); failed += 1; &#125; &#125; NSLog(@\"10次测试,成功登录%d次,失败%d次\",success,failed);&#125; 测试结果: 断言 注:断言结果会记录在测试的log文件中,断言失败则该测试方法不通过. 123456789101112131415161718192021//断言,最基本的测试，如果expression为true则通过，否则打印后面格式化字符串 XCTAssert(expression, format...) //Bool测试: XCTAssertTrue(expression, format...) XCTAssertFalse(expression, format...) //相等测试 XCTAssertEqual(expression1, expression2, format...) XCTAssertNotEqual(expression1, expression2, format...) //double float 对比数据测试使用 XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...) XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...) //Nil测试，XCTAssert[Not]Nil断言判断给定的表达式值是否为nil XCTAssertNil(expression, format...) XCTAssertNotNil(expression, format...) //失败断言 XCTFail(format...)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"}]},{"title":"代码解耦-iOS应用內动态跳转解决方案 Routable-iOS简单使用","date":"2016-12-22T09:31:47.000Z","path":"2016/12/22/代码解耦-iOS应用內动态跳转解决方案 Routable-iOS简单使用 /","text":"前言 在APP开发过程中,必然会遇到在WebView和推送消息中打开其他页面的需求,进一步则是在任何动态界面. 但随着APP越来越大,功能模块越来越复杂,采用传统的控制器跳转方式,需要持有跳转对象,就会造成复杂的依赖链,代码耦合性变强. 采用Routable的方式进行动态界面跳转则不会有这个问题.传统跳转: 1234ProjectDetailViewController* pro = [[ProjectDetailViewController alloc]init];pro.StrID = @\"XX\";pro.Memo = @\"XX\";[self.navigationController pushViewController:pro animated:YES]; Routable跳转: 1[[Routable sharedRouter] open:@\"ProjectDetail/XX/XX\"]; Routable使用 1.注册协议 123456//一般在APP入口didFinishLaunchingWithOptions中进行注册- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; //map规则 @\"跳转标识/:参数1/:参数2....\" [[Routable sharedRouter] setNavigationController:nav]; [[Routable sharedRouter] map:@\"ProjectDetail/:StrID/:Memo/:Name\" toController:[ProjectDetailViewController class]];&#125; 2.使用协议进行跳转 12//open规则 @\"跳转标识/参数1/参数2\"[[Routable sharedRouter] open:@\"ProjectDetail/XX/XX\"]; Routable代码解析 关键方法:sharedRouter map open setNavigationController sharedRouter方法: 123456789//使用dispatch_once初始化单例对象 保证一个程序生命周期中使用同一个Router对象+ (instancetype)sharedRouter &#123; static Routable *_sharedRouter = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _sharedRouter = [[Routable alloc] init]; &#125;); return _sharedRouter;&#125; map方法: 1234567891011121314- (void)map:(NSString *)format toController:(Class)controllerClass withOptions:(UPRouterOptions *)options &#123; if (!format) &#123; @throw [NSException exceptionWithName:@\"RouteNotProvided\" reason:@\"Route #format is not initialized\" userInfo:nil]; return; &#125; if (!options) &#123; options = [UPRouterOptions routerOptions]; &#125; options.openClass = controllerClass; //关键代码 创建UPRouterOptions对象 将传入的类对象作为value 参数字符串作为key存储在可变字典 [self.routes setObject:options forKey:format];&#125; setNavigationController方法: 12//Router对象中有一个navigationController参数 用来保存传入的导航视图控制器 在open方法中会使用这个导航视图控制器进行跳转@property (readwrite, nonatomic, strong) UINavigationController *navigationController; open方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//调用Router类中的该方法 将传入的参数格式化成RouterParams对象//再通过RouterParams对象从self.routes中获取对应的openClass类对象//使用navigationController进行跳转- (void)open:(NSString *)url animated:(BOOL)animated extraParams:(NSDictionary *)extraParams&#123; RouterParams *params = [self routerParamsForUrl:url extraParams: extraParams]; UPRouterOptions *options = params.routerOptions; if (options.callback) &#123; RouterOpenCallback callback = options.callback; callback([params controllerParams]); return; &#125; if (!self.navigationController) &#123; if (_ignoresExceptions) &#123; return; &#125; @throw [NSException exceptionWithName:@\"NavigationControllerNotProvided\" reason:@\"Router#navigationController has not been set to a UINavigationController instance\" userInfo:nil]; &#125; UIViewController *controller = [self controllerForRouterParams:params]; if (self.navigationController.presentedViewController) &#123; [self.navigationController dismissViewControllerAnimated:animated completion:nil]; &#125; if ([options isModal]) &#123; if ([controller.class isSubclassOfClass:UINavigationController.class]) &#123; [self.navigationController presentViewController:controller animated:animated completion:nil]; &#125; else &#123; UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:controller]; navigationController.modalPresentationStyle = controller.modalPresentationStyle; navigationController.modalTransitionStyle = controller.modalTransitionStyle; [self.navigationController presentViewController:navigationController animated:animated completion:nil]; &#125; &#125; else if (options.shouldOpenAsRootViewController) &#123; [self.navigationController setViewControllers:@[controller] animated:animated]; &#125; else &#123; [self.navigationController pushViewController:controller animated:animated]; &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"}]},{"title":"代码优化-更精简的tableView,抽离tableView DataSource Delegate","date":"2016-12-22T08:52:43.000Z","path":"2016/12/22/代码优化-更精简的tableView,抽离tableView DataSource Delegate/","text":"前言 UITableView无疑是我们在开发iOS应用中使用频率非常高的一个控件,使用方法无外乎创建对象,关联delegate,datasource,实现对应方法. 几乎是在每一次使用UITableView的时候,都会去调用几个固定的方法,例如 12345678//返回数量- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;//返回高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;//返回cell实例对象- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath//cell点击事件- (void) tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath 这无疑是多了很多重复性质的代码,是否有办法可以简化UITableView的使用,避免这些重复性质的代码,同时能兼容大部分情况UITableView的使用呢? 将UITableView的Deleaget,DataSource抽离出来无疑是一个比较好的办法,实现一个通用的负责代理方法实现的类,通过block来回调,减少VC代码量. 代码实例通用处理类CustomDeleagte.h1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void (^TableViewCellConfigureBlock)(NSIndexPath* indexPath, id cell, id item);typedef void (^TableViewCellDidSelectBlock)(NSIndexPath* indexPath, id cell, id item);typedef CGFloat (^TableViewCellHeightBlock)(NSIndexPath* indexPath, id item);@interface CustomDeleagte : NSObject &lt;UITableViewDataSource,UITableViewDelegate&gt;- (id)initWithItems:(NSArray *)aItems cellIdentifier:(NSString *)aIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock cellHeightBlock:(TableViewCellHeightBlock)aHeightBlock didSelectBlock:(TableViewCellDidSelectBlock)aDidSelectBlock;- (void)handleTableViewDataSourceAndDelegate:(UITableView*)aTableView;- (id)itemAtIndexPath:(NSIndexPath *)indexPath;@property (nonatomic, copy) NSArray *items;@end 1.TableViewCellConfigureBlock用于传入数据源,加载数据2.TableViewCellDidSelectBlock回调点击事件3.TableViewCellHeightBlock计算cell高度 三个block基本涵盖了UITableView的一般使用. 通用处理类实现CustomDeleagte.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#import \"CustomDeleagte.h\"#import \"UITableViewCell+Extension.h\"@interface CustomDeleagte()@property (nonatomic, copy) NSString* cellIdentigier;@property (nonatomic, copy) TableViewCellConfigureBlock configureCellBlock;@property (nonatomic, copy) TableViewCellDidSelectBlock didSelectBlock;@property (nonatomic, copy) TableViewCellHeightBlock heightBlock;@end@implementation CustomDeleagte- (id)initWithItems:(NSArray *)aItems cellIdentifier:(NSString *)aIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock cellHeightBlock:(TableViewCellHeightBlock)aHeightBlockdidSelectBlock:(TableViewCellDidSelectBlock)aDidSelectBlock&#123; self = [super init]; if (self) &#123; self.items = aItems; self.cellIdentigier = aIdentifier; self.configureCellBlock = aConfigureCellBlock; self.heightBlock = aHeightBlock; self.didSelectBlock = aDidSelectBlock; &#125; return self;&#125;- (id)itemAtIndexPath:(NSIndexPath*)indexPath&#123; return self.items[(NSUInteger)indexPath.row];&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.items.count;&#125;- (UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:self.cellIdentigier]; if (!cell) &#123; [UITableViewCell registerTabelView:tableView nibIdentifier:self.cellIdentigier]; cell = [tableView dequeueReusableCellWithIdentifier:self.cellIdentigier]; &#125; id item = [self itemAtIndexPath:indexPath]; self.configureCellBlock(indexPath,cell,item); return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; id item = [self itemAtIndexPath:indexPath]; id cell = [tableView cellForRowAtIndexPath:indexPath]; self.didSelectBlock(indexPath,cell,item);&#125;//注册delegate,datasource- (void)handleTableViewDataSourceAndDelegate:(UITableView *)aTableView&#123; aTableView.delegate = self; aTableView.dataSource = self;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; id item = [self itemAtIndexPath:indexPath]; return self.heightBlock(indexPath,item);&#125;@end 给UITableViewCell扩展几个方法 UITableViewCell+Extension.h 123456789101112131415161718#import &lt;UIKit/UIKit.h&gt;@interface UITableViewCell (Extension)//注册cell+ (void)registerTabelView:(UITableView*)aTable nibIdentifier:(NSString*)identifier;//载入数据- (void)configure:(UITableViewCell*)aCell custimObj:(id)obj indexPath:(NSIndexPath*)indexPath;//根据数据源计算cell高度 默认返回44.0f+ (CGFloat)getCellHeightWitCustomObj:(id)obj indexPath:(NSIndexPath*)indexPath;@end UITableViewCell+Extension.m 1234567891011121314151617181920212223#import \"UITableViewCell+Extension.h\"@implementation UITableViewCell (Extension)//注册cell+ (void)registerTabelView:(UITableView*)aTable nibIdentifier:(NSString*)identifier&#123; [aTable registerNib:[UINib nibWithNibName:identifier bundle:nil] forCellReuseIdentifier:identifier];&#125;//载入数据- (void)configure:(UITableViewCell*)aCell custimObj:(id)obj indexPath:(NSIndexPath*)indexPath&#123; &#125;//根据数据源计算cell高度 默认返回44.0f+ (CGFloat)getCellHeightWitCustomObj:(id)obj indexPath:(NSIndexPath*)indexPath&#123; return 44.0f;&#125;@end 在自定义cell的类中重写这两个方法configure用于数据加载getCellHeightWitCustomObj用于计算高度 registerTabelView方法在CusetDelegate中用于注册cell到对应tableView 代码中的使用方法 123456789101112131415161718192021self.data = [[NSArray alloc]init];self.tab = [[UITableView alloc]initWithFrame:CGRectMake(0, 0, kScreenWidth, kScreenHeight) style:UITableViewStylePlain];TableViewCellConfigureBlock ConfigBlock = ^(NSIndexPath* indexPath,WelfareRuleCell* cell,id item)&#123; [cell configure:cell custimObj:item indexPath:indexPath];&#125;;TableViewCellDidSelectBlock DidBlock = ^(NSIndexPath* indexPath,id cell,id item)&#123; &#125;;TableViewCellHeightBlock heightBlock = ^CGFloat(NSIndexPath* indexPath,id item)&#123; return [WelfareRuleCell getCellHeightWitCustomObj:item indexPath:indexPath];&#125;;self.customDelegate = [[CustomDeleagte alloc]initWithItems:_data cellIdentifier:@\"WelfareRuleCell\" configureCellBlock:ConfigBlock cellHeightBlock:heightBlock didSelectBlock:DidBlock];[self.customDelegate handleTableViewDataSourceAndDelegate:self.tab];[self.view addSubview:self.tab]; 自定义cell类 1234567891011121314151617181920#import \"WelfareRuleCell.h\"@implementation WelfareRuleCell- (void)awakeFromNib &#123; [super awakeFromNib]; // Initialization code&#125;- (void)configure:(UITableViewCell *)aCell custimObj:(id)obj indexPath:(NSIndexPath *)indexPath&#123; //数据加载 self.XXX = XXX;&#125;+ (CGFloat)getCellHeightWitCustomObj:(id)obj indexPath:(NSIndexPath *)indexPath&#123; //计算高度的代码 return xxx;&#125;@end 后语 使用抽离Delegate和DataSource的方法来使用tableView,控制器中的代码可以被大大的简化,代码逻辑也能更清晰","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"}]},{"title":"iOS实现一个类似readme.io的动效登录界面","date":"2016-12-22T06:36:09.000Z","path":"2016/12/22/iOS实现一个类似readme.io的动效登录界面/","text":"首先引入一个问题—-我们为什么需要动效设计? 我觉得cocoachina的一篇文章很好的阐述了这个问题的答案，包括加强体验舒适度，减弱不可避免的不适感等等！附链接:我们为什么需要动效设计 本文所展示的动效登录界面就是参照文章中列出的readme网站的登录界面所编写的~ 本文效果Demo已经上传到github，点击去下载。 最终效果展示： 第一步：界面搭建 简单的使用storyboard进行界面拖拽,通过界面层次透视图可以清楚看到界面逻辑,猫头鹰的两个圆形手和两个捂住眼睛的手都是imageView，其中捂住眼睛的手是事先放置在输入账户密码的界面后面被遮住。 第二步：动画效果实现 这段代码实现的效果是在0.5s的时间内同时将隐藏在输入框界面后的捂眼手上移到指定位置，以及将本来趴在框上的手，一边向指定位置移动一边缩小一直到完全消失。 由于两个手的颜色是相同的，移动轨迹上又是重叠的，所以实际效果会使人产生一种错觉，这个手是在慢慢变化的。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"}]},{"title":"iOS开发-图形验证码绘图实例","date":"2016-12-22T06:05:22.000Z","path":"2016/12/22/iOS开发-图形验证码绘图实例/","text":"前言: 公司项目需求获取短信验证码前需要输入图形验证码防止羊毛客使用脚本批量注册平台账号想了想还是自己重新实现了一下. 思路 1.容器创建 1.1 代码创建 1.2 nib文件使用 2.创建验证码字符串 2.绘图 2.1 绘字 2.2 绘干扰线 4.点击刷新机制 代码实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//// ImageCodeView.h// VerCodeView//// Created by hpjr on 2016/12/22.// Copyright © 2016年 sands. All rights reserved.//#import \"ImageCodeView.h\"#define CODE_LENGTH 4#define ARCNUMBER arc4random() % 100 / 100.0#define ARC_COLOR [UIColor colorWithRed:ARCNUMBER green:ARCNUMBER blue:ARCNUMBER alpha:0.2]@implementation ImageCodeView//初始化- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self setupUI]; &#125; return self;&#125;//兼容nib使用- (void)awakeFromNib&#123; [super awakeFromNib]; [self setupUI];&#125;//设置默认参数- (void)setupUI&#123; self.CodeArr = @[@\"0\",@\"1\",@\"2\",@\"3\",@\"4\",@\"5\",@\"6\",@\"7\",@\"8\",@\"9\",@\"A\",@\"B\",@\"C\",@\"D\",@\"E\",@\"F\",@\"G\",@\"H\",@\"I\",@\"J\",@\"K\",@\"L\",@\"M\",@\"N\",@\"O\",@\"P\",@\"Q\",@\"R\",@\"S\",@\"T\",@\"U\",@\"V\",@\"W\",@\"X\",@\"Y\",@\"Z\",@\"a\",@\"b\",@\"c\",@\"d\",@\"e\",@\"f\",@\"g\",@\"h\",@\"i\",@\"j\",@\"k\",@\"l\",@\"m\",@\"n\",@\"o\",@\"p\",@\"q\",@\"r\",@\"s\",@\"t\",@\"u\",@\"v\",@\"w\",@\"x\",@\"y\",@\"z\"]; UITapGestureRecognizer* changeCode = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(changeCode)]; [self addGestureRecognizer:changeCode]; self.backgroundColor = ARC_COLOR; [self getStrCode];&#125;//随机生成验证码字符串- (void)getStrCode&#123; self.backgroundColor = ARC_COLOR; NSMutableString* tmpStr = [[NSMutableString alloc] initWithCapacity:5];; for (int i = 0; i &lt; CODE_LENGTH; i++) &#123; NSInteger index = arc4random() % (self.CodeArr.count-1); [tmpStr appendString:[self.CodeArr objectAtIndex:index]]; &#125; self.CodeStr = [NSString stringWithFormat:@\"%@\",tmpStr];&#125;//刷新验证码- (void)changeCode&#123; [self getStrCode]; [self setNeedsDisplay];&#125;- (void)drawRect:(CGRect)rect &#123; [super drawRect:rect]; CGSize cSize = [@\"A\" sizeWithAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];//计算单个字所需空间 int width = rect.size.width / self.CodeStr.length - cSize.width;//间距 int height = rect.size.height - cSize.height;//可浮动高度 CGPoint point; //绘码 float pX, pY; for (int i = 0; i &lt; self.CodeStr.length; i++) &#123; pX = arc4random() % width + rect.size.width / self.CodeStr.length * i; pY = arc4random() % height; point = CGPointMake(pX, pY); unichar c = [self.CodeStr characterAtIndex:i]; NSString *textC = [NSString stringWithFormat:@\"%C\", c]; [textC drawAtPoint:point withAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;]; &#125; //干扰线 CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetLineWidth(context, 1.0); for(int cout = 0; cout &lt; 10; cout++) &#123; CGContextSetStrokeColorWithColor(context, [ARC_COLOR CGColor]); pX = arc4random() % (int)rect.size.width; pY = arc4random() % (int)rect.size.height; CGContextMoveToPoint(context, pX, pY); pX = arc4random() % (int)rect.size.width; pY = arc4random() % (int)rect.size.height; CGContextAddLineToPoint(context, pX, pY); CGContextStrokePath(context); &#125;&#125;@end 最终效果 项目代码地址 https://github.com/yushengchu/VerCodeView","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"}]},{"title":"Appium+Python iOS自动化测试从0-1","date":"2016-12-20T11:22:01.000Z","path":"2016/12/20/Appium+Python iOS自动化测试从0-1/","text":"1.Appium环境搭建参考官网appium.io给出的终端命令进行安装. &gt; brew install node //安装node &gt; npm install -g appium //安装 appium &gt; npm install wd //安装 appium client &gt; appium &amp; // 启动 appium &gt; node your-appium-test.js //执行脚本 以上安装的是终端版的appium,再安装一个图形界面的appium方便查看界面元素.2.测试包编译 appium参数设置 2.1测试包编译: 1.跟开发要.app后缀的测试包 2.本地搭建iOS开发环境 使用xcodebuilder命令编译 xcodebuild -sdk iphonesimulator -target YouProject ２.２参数设置 图形界面: 点击选择平台,跳出设置参数界面,选择好运行设备,版本号,测试app的路径点击放大镜图标运行. 成功运行后会弹出模拟器并自动运行测试项目． Appium inspector: 例:选中一个控件,点击tap按钮,脚本框內自动生成脚本,模拟器自动根据动作进行操作. 终端使用: 终端使用需要另外安装一个appium client,按照用来编写脚本程序的语言不同安装对应,具体参照百度. 打开终端,输入appium &amp;即可启动 新建一个终端，进入脚本所在目录运行脚本 模拟器自动运行 3.第一个Python测试脚本,基本API解析 注意点：测试方法必须以test开头或结尾","tags":[{"name":"Appium","slug":"Appium","permalink":"http://yoursite.com/tags/Appium/"},{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"Appium+Python测试-输出测试报告","date":"2016-12-20T09:15:09.000Z","path":"2016/12/20/Appium+Python测试-输出测试报告/","text":"1.导入HTMLTestRunner 在终端依次使用Python——import sys——print sys.path命令获取site-packages文件夹目录. 将下载的HTMLTestRunner.py文件放入site-packages,在脚本文件中引用,不出错即可. 2.修改启动测试代码 3.查看输出结果 输出结果可以分为两部分:终端输出和HTML记录输出 终端输出:（．代表案例成功Ｆ代表失败） HTML输出:","tags":[{"name":"Appium","slug":"Appium","permalink":"http://yoursite.com/tags/Appium/"},{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"unittest单元测试案例编写思路","date":"2016-12-20T09:06:07.000Z","path":"2016/12/20/unittest测试案例编写思路/","text":"编写测试框架的基本思路: #coding=utf-8 //1.先设置编码，utf-8可支持中英文，如上，一般放在第一行 //2.注释：包括记录创建时间，创建人，项目名称。 //3.导入unittest模块 //4.定义测试类，父类为unittest.TestCase。 //5.定义setUp()方法用于测试用例执行前的初始化工作。(设置测试包参数) //6.定义测试用例，以“test_”开头命名的方法(使用unittest.TestCase类下的断 言对用例是否测试通过进行判断,也可以使用@unittest.skip来跳过测试用例) //7.定义tearDown()方法用于测试用例执行之后的善后工作。 //执行测试用例,并输出测试结果","tags":[{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"iOS开发runtime笔记","date":"2016-09-19T07:02:58.000Z","path":"2016/09/19/iOS开发-runtime笔记/","text":"什么是runtime 我们写的代码在程序运行过程中都会被转化为runtime的C代码执行,例如[target doSomething];会被转化为objc_msgSend(target,@selector(doSomething));.在runtime中,类用结构体来表示 相关定义 1234567891011//描述类中的一个方法typedef struct objc_method *Method;//实例变量typedef struct objc_ivar *Ivar;//类别Categorytypedef struct objc_category *Category;//类中声明的属性typedef struct objc_property *objc_property_t; 类在runtime中的表示 12345678910111213141516171819//类在runtime中的表示struct objc_class &#123; Class isa;//指针，顾名思义，表示是一个什么， //实例的isa指向类对象，类对象的isa指向元类#if !__OBJC2__ Class super_class; //指向父类 const char *name; //类名 long version; long info; long instance_size struct objc_ivar_list *ivars //成员变量列表 struct objc_method_list **methodLists; //方法列表 struct objc_cache *cache;//缓存 //一种优化，调用过的方法存入缓存列表，下次调用先找缓存 struct objc_protocol_list *protocols //协议列表 #endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 通过runtim获取属性列表 12345678910111213141516171819202122232425262728293031- (void)getMethonAndProperty&#123; unsigned int count; //获取属性列表 objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count); for (unsigned int i = 0; i &lt; count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSLog(@\"property------&gt;%@\",[NSString stringWithUTF8String:propertyName]); &#125; //获取方法列表 Method *methodList = class_copyMethodList([self class], &amp;count); for (unsigned int i = 0; i &lt; count; i++) &#123; Method method = methodList[i]; NSLog(@\"method------&gt;%@\",NSStringFromSelector(method_getName(method))); &#125; //获取成员变量列表 Ivar *ivarList = class_copyIvarList([self class], &amp;count); for (unsigned int i = 0; i &lt; count; i++) &#123; Ivar myIvar = ivarList[i]; NSLog(@\"myIvar------&gt;%@\",[NSString stringWithUTF8String:ivar_getName(myIvar)]); &#125; //获取协议 __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count); for (unsigned int i = 0; i &lt; count; i++) &#123; Protocol* mypro = protocolList[i]; NSLog(@\"prorocol------&gt;%@\",[NSString stringWithUTF8String:protocol_getName(mypro)]); &#125; &#125; 方法调用 如果实例对象调用实例方法,会到实例的isa指针指向的对象操作如果是调用类方法,就会到类对象的isa指针指向的对象中操作 1.先在相应操作的对象中的缓存方法列表去找调用的方法,找到则实现2.如果没找到则去相应对象的方法列表去找,找到则实现3.如果没找到则去相应对象的父类指针所指向的对象中执行1,2,找到则执行4.一直没找到,转向拦截调用,没有重写拦截调用的方法,则报错. 重写父类的方法并不是覆盖父类的方法,而是在子类对象中找到这个方法后就不会再去父类中寻找 拦截调用 在方法调用中说到,如果找不到方法会转向拦截,那拦截调用时什么??拦截调用就是在找不到调用的方法,程序崩溃之前,你可以通过重写NSObjct的四个方法来处理. 12345+ (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel;//后两个方法需要转发到其他的类处理- (id)forwardingTargetForSelector:(SEL)aSelector;- (void)forwardInvocation:(NSInvocation *)anInvocation; 第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。 第二个方法和第一个方法相似，只不过处理的是实例方法。 第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target。 第四个方法是将你调用的不存在的方法打包成NSInvocation传给你。做完你自己的处理后，调用invokeWithTarget:方法让某个target触发这个方法。 动态添加方法 重写了拦截调用的方法切返回了YES,我们要怎么处理呢?有一个办法是根据传进来的SEL类型的selector动态添加一个方法 首先从外部隐式调用一个不存在的方法","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/移动开发/"}]}]